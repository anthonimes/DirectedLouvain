// File: main_community.cpp
// -- community detection, sample main file
//-----------------------------------------------------------------------------
// Community detection
// Based on the article "Fast unfolding of community hierarchies in large networks"
// Copyright (C) 2008 V. Blondel, J.-L. Guillaume, R. Lambiotte, E. Lefebvre
//
// This program must not be distributed without agreement of the above mentionned authors.
//-----------------------------------------------------------------------------
// Author   : E. Lefebvre, adapted by J.-L. Guillaume and then Anthony Perez and Nicolas Dugu√© for directed modularity
//-----------------------------------------------------------------------------
// see readme.txt for more details

#include "../include/community.hpp"
#include <unistd.h>

using namespace std;

/* Arguments variables */
string filename = "";
string filename_part = "";
bool weighted = false;
int nb_pass = 0;
double precision = 0.000001;
int display_level = -2;
bool verbose = false;
bool reproducibility = false;
bool renumbering = true;
bool improvement = true;

void usage(char * prog_name) {
    cerr << "usage: " << prog_name << " input_file [-w weight_file] [-p part_file] [-q epsilon] [-l display_level] [-v] [-h]" << endl << endl;
    cerr << "input_file: file containing the graph to decompose in communities." << endl;
    cerr << "\tcan be any file under the edgelist form _or_ a binary file generated by the -r option" << endl;
    cerr << "-r for the sake of fast reproducibility, the graph is written in binary form." << endl;
    cerr << "-w \tread the graph as a weighted one (weights are set to 1 otherwise)." << endl;
    cerr << "-n \tto indicate that the input graph is already numbered from 0 to n-1 (improves performance)" << endl;
    cerr << "-p file\tstart the computation with a given partition instead of the trivial partition." << endl;
    cerr << "\tfile must contain lines \"node community\"." << endl;
    cerr << "-q eps\ta given pass stops when the modularity is increased by less than epsilon." << endl;
    cerr << "-l k\tdisplays the graph of level k rather than the hierachical structure." << endl;
    cerr << "\tif k=-1 then displays the hierarchical structure rather than the graph at a given level." << endl;
    cerr << "-v\tverbose mode: gives computation time, information about the hierarchy and modularity." << endl;
    cerr << "-h\tshow this usage message." << endl;
    exit(0);
}

void parse_args(int argc, char **argv) {
    if(argc == 1) {
        usage(argv[0]);
        exit(1);
    }

    opterr = 0;
    /* Parsing arguments using getopt */
    int arg;
    while ((arg = getopt (argc, argv, "f:rwnp:q:l:vh")) != -1) {
        switch (arg) {
            case 'f':
                filename = optarg;
                break;
            case 'r':
                reproducibility = true;
                break;
            case 'w':
                weighted = true;
                break;
            case 'n':
                renumbering = false;
                break;
            case 'p':
                filename_part = optarg;
                break;
            case 'q':
                precision = atof(optarg);
                break;
            case 'l':
                display_level = atoi(optarg);
                break;
            case 'v':
                verbose = true;
                break;
            case 'h':
                usage(argv[0]);
                break;
            case '?':
                if (optopt == 'f')
                    cerr << "Option -" << (char)optopt << " requires an argument (input graph)" << endl;
                else if (optopt == 'p')
                    cerr << "Option -" << optopt << " requires an argument (partition file name)." << endl;
                else if (optopt == 'q')
                    cerr << "Option -" << optopt << " requires an argument (modularity gain threshold)." << endl;
                else if (optopt == 'l')
                    cerr << "Option -" << optopt << " requires an argument (level to display)." << endl;
                else if (isprint (optopt))
                    cerr << "Unknown option `-" << optopt << "'." << endl;
                else
                    cerr << "Unknown option character `\\x " << optopt << "'." << endl;
                exit(1);
            default:
                abort();
        }
    }
}

void display_time(const char * str) {
    time_t rawtime;
    time( & rawtime);
    cerr << str << ": " << ctime( & rawtime);
}

int main(int argc, char ** argv) {
    parse_args(argc, argv);

    ofstream foutput;
    foutput.open("modularity_values_directed_louvain.txt", fstream::app | fstream::binary);

    if (verbose)
        display_time("Begin");
    Community *c = new Community(filename, weighted, -1, precision, reproducibility, renumbering);
    if (filename_part != "")
        c->init_partition(filename_part);
    double mod = c->modularity(), new_mod;
    Graph * g = NULL;
    int level = 0;

    time_t time_begin, time_end;
    time( & time_begin);
    do {
        const Graph *community_graph = c->get_graph();
        ++nb_pass;
        if (verbose) {
            cerr << "level " << level << ":\n";
            display_time("  start computation");
            cerr << "  network size: " <<
                community_graph->get_nodes() << " nodes, " <<
                community_graph->get_arcs() << " arcs, " <<
                community_graph->get_total_weight() << " weight." << endl;
        }

        improvement = c->one_level();
        new_mod = c->modularity();
        if (++level == display_level)
            community_graph->display();
        if (display_level == -1)
            c->display_partition();
        g = c->partition_to_graph();
        delete c;
        c = new Community(g, -1, precision);
        delete g;
        if (verbose)
            cerr << "  modularity increased from " << mod << " to " << new_mod << endl;

        mod = new_mod;
        if (verbose)
            display_time("  end computation");
        if (filename_part != "" && level == 1) // do at least one more computation if partition is provided
            improvement = true;
    } while (improvement);

    delete c;
    time(&time_end);
    if (verbose) {
        display_time("End");
        cerr << "Total duration: " << (time_end - time_begin) << " sec." << endl;
    }
    cerr << "modularity: " << new_mod << endl;
    foutput << new_mod << endl;
    foutput.close();
}
